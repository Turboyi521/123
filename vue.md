##1. 对Vue的理解
	vue是一个前端JS库
	MVVM模式的实现
	作用: 动态构建用户界面
	重要技术: 模板与数据绑定(angular), 组件与虚拟DOM(react)

##2. MVVM设计模式
	M: Model(模型), vue中是data(为view提供数据)
	V: View(视图), vue中是模板页面(显示data中的数据)
	VM: ViewModel(视图模型), vue中是Vue实例对象(管理者: 数据绑定/DOM监听) 
![](https://i.imgur.com/G0kcQBv.png)

##3.你对模板的理解
	html中嵌套js
	指令: <p v-text='msg'>
	大括号表达式: {{msg}}

##4. vue的常用配置选项及其作用(5个)
	el: 最外层元素选择器
	data: 状态数据
	computed: 计算属性
	methods: 事件回调函数
	watch: 监视属性变化

##5. 对计算属性的理解
	什么时候用计算属性?
		模板显示要显示的数据是根据n个已有的相关数据进行计算来确定
	getter: get方法, 当读取属性值时/相关数据发生了改变自动调用, 根据相关数据进行计算并返回结果, this就是vm
	setter: set方法, 当修改了当前属性的值自动调用, 监视属性值的变化去更新相关数据, this就是vm
## 6. 组件化编码应用界面的基本流程
	1). 抽取组件
	2). 实现静态组件
	3). 实现动态组件
		a. 动态显示初始化数据
		b. 交互

## 7. vue的vm对象/组件对象的生命周期
	1). 初始化
		beforeCreate()
		created()
		beforeMount()
		mounted(): 异步任务(发ajax请求/启动定时器)
	2). 更新
		beforeUpdate()
		updated()
	3). 死亡
		beforeDestroy(): 收尾工作(清除定时器)
		destroyed()

##8. vue的7个指令及其作用
	v-text: 设置标签体文本
	v-html: 设置标签体子标签
	v-if/v-else/v-show: 显示/隐藏
	v-for: 遍历显示列表
	v-bind: 强制绑定表达式, 简写:
	v-on: 绑定事件监听, 简写@
	v-model: 双向数据绑定
## 9. vue组件间通信的几种方式
	1). props: 父子组件间相互通信, 可以传递一般数据/函数, 问题: 隔代组件/兄弟组件麻烦
	2). vue自定义事件: 代替函数类型的prop, 隔代/兄弟组件不方便
	3). 消息订阅与发布(pubsub库): 任意关系组件间都可以
	4). slot: 通信的是标签, 而不仅仅是数据
	5). vuex: 后面讲

##10. vue项目中如何与后台通信
	1). 通过ajax请求与后台通信
	2). 常用的库有2个
		vue-resource: vue的插件, 用于vue1.x
		axios: 独立的第三方库, 用于vue2.x
	3). 执行请求代码的时机
		初始化异步显示: mounted()
		特定用户操作后异步显示: 事件回调函数或相关函数中


## 11. vue-router提供了哪些语法?
	1). 1个函数:
	  VueRoute: 路由构建函数, 用于创建路由器对象, 配置路由
	2). 2个对象
	  $route: 代表当前路由的对象, 包含当前路由相关信息(path, params参数, query参数)
	  $router: 代表路由器对象, 包含控制路由跳转的方法(push/replce/back())
	3). 3个标签
	  <router-link>: 路由链接, 生成路由链接
	  <router-view>: 路由视图, 显示当前路由组件
	  <keep-alive>: 缓存路由组件对象

# 12. JS事件循环机制(图)
![](https://i.imgur.com/4gnmsJR.png)

## 13. 比较函数的call()/apply()/bind()
	1). call(obj, param1, param2)/apply(obj, [[param1, param2])
		调用/执行函数
		只是强制指定函数中的this为第一个参数指定的对象
		如果函数执行需要传参数, call是依次传递, apply需要封装成数组传递
	2). bind()
		返回一个新函数, 不会自动执行, 需要手动执行
		强制指定函数中的this为第一个参数指定的对象
		新函数内部会原样调用原函数

## 14. debug调试
	1). 调试的目的
      1). 查找bug: 不断缩小可疑代码的范围
      2). 查看程序的运行流程(用于熟悉新接手项目的代码)
    
    2). 如何开启调试模式
      1). 添加语debugger句: 程序运行前     此方式用打包后才运行的项目
      2). 添加(打)断点: 程序运行前或者过程中   此方式用运行源码js
    
    3). 如何进行调试操作
      resume: 恢复程序执行(可能执行完或者进入下一个断点处)
      step ove: 单步跳转, 尝试执行完当前语句, 进入下一条(如果内部有断点, 自动进入内部断点处)
      step into: 跳入, 进入当前调用函数内部
      step out: 跳出, 一次性执行完当前函数后面所有语句,并出去
      deactivate breakpoints: 使所有断点暂时失效
      
      call stack: 显示是程序函数调用的过程
      scop: 当前执行环境对应的作用域中包含的变量数据
      breakpoints: 断点列表

##15. vue数据代理
	1). 是什么?
		通过vm对象来代理data对象中所有属性的操作
	2). 作用:
		简化操作vm中的data对象中的数据
	3). 实现基本原理
		1). 通过Object.defineProperty()给vm添加与data对象的属性对应的属性描述符
    	2). 所有添加的属性都包含getter/setter
    	3). 在getter/setter内部去操作data中对应的属性数据

##16. vue模板解析
	1). 目的
		实现初始化显示
	2). 整体流程
		1). 将el的所有子节点取出, 添加到一个新建的文档fragment对象中
    	2). 对fragment中的所有层次子节点递归进行编译解析处理
      	3). 将解析后的fragment添加到el中显示
	3). 编译/解析包含大括号表达式的文本节点: textNode.textContent = value
	4). 编译事件指令: elementNode.addEventListener('eventName', callback)
	5). 编译一般指令: elementNode.xxx = value
##17. 说说你对回调函数的理解
	1). 什么函数才是回调函数
		你定义的
		你没有直接调用
		它最终执行了
	2). 回调函数相关的3个问题
		什么时候执行
		用来做什么的
		函数中的this是谁

##18. 说说数据绑定的理解和基本原理
	1). 作用:
		实现数据的更新显示
	2). 基本原理:
		a.通过Object.defineProperterty()给data中所有属性添加setter/getter, 实现数据劫持
		b.为每个data中的属性创建一个对应的dep对象, 一旦属性数据变化, 通知dep对象
		c.为模板中的每个表达式创建对应的watcher, 并关联到对应的dep上
		d.一旦dep收到数据变化的通知, 会通知所有关联的watcher, watcher收到通知后就更新对应的节点

##19. 说说vue双向数据绑定的基本原理
	1). 双向数据绑定是建立在单向数据绑定(model==>View)的基础之上的
	2). 双向数据绑定的实现流程:
      	a. 在解析v-model指令时, 给当前元素添加input监听
      	b. 当input的value发生改变时, 将最新的值赋值给当前表达式所对应的data属性
	
##20 Vue的MVVM实现结构图
![](https://i.imgur.com/BaYoa3c.png)

## 21. 模板中显示数据的来源 
	data
	props
	computed: 根据data/props/其它compute属性/vuex的state或getters计算产生

## 22. 说说你对async和await的理解和使用
	简化promise的使用(不使用回调函数)
	以同步编码方式实现异步流程
	使用await: 调用返回promise的函数, 如果想直接异步结果数据, 在左侧使用
	使用async: 在使用await所在的函数定义左侧

## 23. 什么是接口, 如何对接口
	1). 接口: url / 请求方式 / 请求参数格式 / 响应数据格式
	2). 对接口: 根据接口文档请求后台, 看真实接口与文档是否一致

## 24. 如何判断函数中的this
	1). 正常情况: 执行函数的方式决定了函数中的this
		直接调用: fn()       window
		new调用: new fn()   新创建的对象 
		对象调用: obj.fn()   obj对象
		call/apply调用: fn.call(obj)   第一个参数指定的对象
	2). 特别情况:
		bind()返回的函数: fn.bind(obj)()  第一个参数指定的对象
		箭头函数: 使用的外部的this(内部没有自己的this)
		回调函数
			定时器回调/ajax回调/数组遍历相关方法回调: window
			dom事件监听回调: dom元素
			组件生命周期回调: 组件对象 

## 25. Vuex的结构图
![](https://i.imgur.com/m5f188j.png)

##26. 对json数据的理解
	1). 什么: json是一种用来存储结构化数据的文本数据结构
	2). 优点: 小巧, 可以轻松的与js相互转换
	3). 整体类型: 
		json对象: {}, 与js对象对应
		json数组: []  与js数组对应
	4). 组成: 
		结构: 类型与名称
		值
	5). 模拟json数据:
		与真实json数据在结构上要相同, 值可以不同

##27. 对mock数据的理解
	1). 对于前后台分离的项目来说, 前后台可以独立开发, 当后台还没有写好时, 前台应用就可以编写了
	2). 前台应用需要自己mock数据接口动态为前台提供数据, 当真实接口完成后, 切换到真实接口即可
	3). 要求: mock的json数据与真实接口的数据在结构上要相同
	4). 工具包: mockjs

##28. 对原型链的理解
	1). 作用: 原型链用于查找对象的属性
	2). 什么: 实例对象上都会有一个隐式原型属性(__proto__), 它指向的就是原型对象, 而原型对象也有__proto__属性指向它的原型对象
	3). 为什么__proto__指向的是原型对象?
		构造函数对象上有显式原型属性(prototype), 它指向的就是原型对象
		实例对象的__proto__属性被赋值为构造函数的prototype属性值

##29. 作用域链的理解
	1). 作用: 作用链用来查找变量
	2). 什么: 多个由内向外作用域形成的链
	3). 作用域: 一块代码区域, 分类全局作用域和函数/局部作用域, ES6有了块作用域

##30. 闭包的理解
	1). 如何产生闭包?
		2个函数嵌套
		内部函数引用了外部函数内的局部变量
		执行外部函数
	2). 是什么?
		包含了那个局部变量的容器
		它被内部函数对象引用着
	2). 作用?
		延长局部变量的生命周期
		使函数外部可以多次间接操作到函数内部的数据
	3). 应用?
		循环遍历加监听
		IIFE定义模块
		jQuery内部
##31. 说说vue组件间5种通信方式并比较
	1). props
		父子组件间通信的基本方式
	    属性值的2大类型: 
	        一般: 父组件-->子组件
	        函数: 子组件-->父组件
		隔层组件间传递: 必须逐层传递(麻烦)
		兄弟组件间: 必须借助父组件(麻烦)
	2). vue自定义事件
		子组件与父组件的通信方式
	    用来取代function props
	    不适合隔层组件和兄弟组件间的通信
	3). 消息订阅和发布
		适合于任何关系的组件间通信
		缺点: 管理不够集中
	4). vuex
		多组件共享状态(数据的管理)
	    组件间的关系也没有限制
	    功能比pubsub强大, 更适用于vue项目
	5). slot
		通信是带数据的标签
	    注意: 标签是在父组件中解析
## 32. 区别localStorage和sessionStorage, session与cookie
	localStorage: 浏览器端持久化存储, 关闭浏览还存在, 最大5MB(基本没限制了)
	sessionStorage: 浏览器端内存存储, 关闭浏览器不存在
	session: 服务器端创建, 服务器端保存, 依赖于cookie
	cookie: 服务器端创建, 浏览器端保存, 请求携带对应cookie, 长度和数量有限制(4kb)

## 33. 区别v-if与v-show
	如果频繁切换使用v-show比较合适
	一旦涉及到初始化模板显示3层表达式数据, 使用v-if可以解决问题

## 34. 关于2个引用变量指向同一个对象的2个问题
	1). 2个引用变量指向同个对象, 通过一个引用变量改变对象内部的数据, 另一个引用变量看到的新的
	2). 2个引用变量指向同个对象, 让一个引用变量指向一个新的对象, 另一个引用变量看到的还是原来的对象
## 35. 前台异步显示数据效果的编码的3个部分
	ajax
	  ajax请求函数
	  接口请求函数
	vuex
	  state
	  mutation-types
	  actions
	  mutations
	组件
	  dispatch(): 异步获取后台数据到vuex的state
	  mapState()/mapGetters(): 从vuex的state中读取对应的数据
	  模板中显示